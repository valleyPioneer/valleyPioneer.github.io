<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/17/JVM类加载双亲(父亲)委托模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/17/JVM类加载双亲(父亲)委托模式/" itemprop="url">JVM类加载双亲(父亲)委托模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-17T00:34:14+08:00">
                2018-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>除了java虚拟机自带的根类加载器之外，其余的类加载器都有且只有一个父加载器。</p>
<h2 id="根类加载器-BootStrap"><a href="#根类加载器-BootStrap" class="headerlink" title="根类加载器(BootStrap)"></a>根类加载器(BootStrap)</h2><p>该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。例如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。</p>
<h2 id="扩展类加载器-Extension"><a href="#扩展类加载器-Extension" class="headerlink" title="扩展类加载器(Extension)"></a>扩展类加载器(Extension)</h2><p>它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库，如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类。</p>
<h2 id="系统类加载器-System-App"><a href="#系统类加载器-System-App" class="headerlink" title="系统类加载器(System/App)"></a>系统类加载器(System/App)</h2><p>也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。</p>
<p><strong>父子加载器并非继承关系，也就是说子加载器不一定是继承了父加载器。</strong></p>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>除了以上虚拟机自带的加载器以外，用户还可以定制自己的类加载器（User-defined Class Loader）。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器应该继承ClassLoader类。</p>
<p><img src="http://www.itzhai.com/wp-content/uploads/2011/11/20111105-JVM001.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class sampleClass = loader2.loadClass(<span class="string">"Sample"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>loader2首先从自己的命名空间中查找Sample类是否已经被加载，如果已经加载，就直接返回代表Sample类的Class对象的引用。</p>
<p>如果Sample类还没有被加载，loader2首先请求loader1代为加载，loader1再请求系统类加载器代为加载，系统类加载器再请求扩展类加载器代为架子啊，扩展类加载器在请求根类加载器代为加载。若根加载器和扩展加载器都不能加载，则系统类加载器尝试加载，若能加载成功，则将Sample类所对应的Class对象的引用返回给loader1，loader1再将引用返回给loader2，从而成功将Sample类加载进虚拟机。若系统类加载器不能加载Sample类，则loader1尝试加载Sample类，若laoder1也不能成功加载，则loader2尝试加载。若所有的父加载器及laoder2本身都不能加载，则抛出ClassNotFoundException异常。</p>
<h2 id="加载器之间的关系"><a href="#加载器之间的关系" class="headerlink" title="加载器之间的关系"></a>加载器之间的关系</h2><p>加载器之间的父子关系实际上指的是加载器对象之间的<strong>包装关系==，而不是类之间的继承关系。一对父子加载器==可能是同一个加载器类的两个实例</strong>，也可能不是。在子加载器对象中包装了一个父加载器对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader1 = <span class="keyword">new</span> MyClassLoader();  </span><br><span class="line"><span class="comment">//参数loader1将作为loader2的父加载器  </span></span><br><span class="line">ClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(loader1);</span><br></pre></td></tr></table></figure>
<h2 id="双亲委托模式的优点"><a href="#双亲委托模式的优点" class="headerlink" title="双亲委托模式的优点"></a>双亲委托模式的优点</h2><p>父委托机制的优点是能够提高软件系统的安全性。因为在此机制下，<strong>用户自定义的类加载器不可能加载应该由父加载器加载的可靠类</strong>，从而防止不可靠甚至恶意的代码代替由父加载器加载的可靠代码。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>每个类加载器都有自己的命名空间，<strong>命名空间由该加载器及所有父加载器所加载的类组成</strong>。在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。</p>
<h2 id="运行时包"><a href="#运行时包" class="headerlink" title="运行时包"></a>运行时包</h2><p><strong>由同一类加载器加载的属于相同包的类</strong>组成了运行时包。决定两个类是不是属于同一个运行时包，不仅要看它们的包名是否相同，还要看定义类加载器是否相同。只有属于同一运行时包的类才能相互访问包可见（即默认访问级别）的类和成员。这样的限制能避免用户自定义的类冒充核心类库的类，去访问核心类库的包可见成员。假设用户自己定义了一个java.lang.Spy，并用用户自定义的类加载器加载，由于java.lang.Spy和核心类库java.lang.*由不同的加载器加载，它们属于不同的运行时包，所以java.lang.Spy不能访问核心类库java.lang包中的包可见成员。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/13/RTMP、RTSP、HLS、HTTP FLV、SIP区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/13/RTMP、RTSP、HLS、HTTP FLV、SIP区别/" itemprop="url">RTMP、RTSP、HLS、HTTP FLV、SIP区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-13T00:34:14+08:00">
                2018-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><p>用RTMP方式： 通过NetConnection连接到FMS(Flash Media Server)或Red5服务器，并实时播放服务器的FLV文件，这种方式可以任意选择视频播放点，并不象HTTP方式需要缓存完整个FLV文件到本地才可以任意选择播放点，其优点就是在本地缓存里是找不到这个FLV文件的。其优点就是FLV不会缓存在客户端，FLV的保密性好，其缺点就是消耗服务器资源，连接始终是实时的。</p>
<p>由以上分析可知，Http方式是本地播放，而RTMP方式是服务器实时播放.</p>
<h2 id="RTSP"><a href="#RTSP" class="headerlink" title="RTSP"></a>RTSP</h2><p>RTSP: RTSP 1.0标准的制订者没有充分预测到互联网带宽的快速增长，以及由于IPv4地址短缺导致的NAT技术的广泛使用，还有代理服务器的大量存在，它在传输可靠性和易用性上都存在一定的缺陷。虽然各家厂商都做了一定程度的修补，比如支持RTSP over HTTP，支持NAT穿透等，但仍然于事无补。在2005之后网络视频大爆炸的几年中，RTSP 1.0并没有得到youtube, hulu, 土豆，优酷等视频服务提供商的青睐，相反，Adobe公司开发的私有流媒体技术RTMP以其优秀的易用性和富媒体的一体化集成，得到了多数视频服务提供商的追捧，成为了事实上的标准.</p>
<h2 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h2><p>HLS(Http Living Streaming): 从2010年起，苹果开始在iOS设备上支持一种叫做”Live HTTP”的流媒体技术，并宣布在iOS上不会支持RTSP和Flash技术。HLS本质上就是基于HTTP的文件分段下载。在带宽充裕的前提下，live HTTP能够实现跟RTSP和RTMP同样的流媒体播放效果，同时得到了更好的易用性，更简单的控制。<br>在最新一代的超文本标识语言HTML5中，视频文件的点播，同样也采用了HTTP作为其承载协议</p>
<p>基于.m3u8配置文件和.ts视频文件</p>
<p>ios、安卓平台原生支持</p>
<h2 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP FLV"></a>HTTP FLV</h2><p>先通过服务器将FLV下载到本地缓存，然后再通过NetConnection的本地连接来播放这个FLV，这种方法是播放本地的视频，并不是播放服务器的视频。因此在本地缓存里可以找到这个FLV。其优点就是服务器下载完这个FLV，服务器就没有消耗了，节省服务器消耗。其缺点就是FLV会缓存在客户端，对FLV的保密性不好。</p>
<h2 id="SIP"><a href="#SIP" class="headerlink" title="SIP"></a>SIP</h2><p>SIP是基于文本的一种应用层控制协议，用于创建、修改和释放一个或多个参与者的会话。</p>
<p>SIP是建立VOIP连接的IETF标准</p>
<p>在SIP网络内每个<strong>网络元素==被标识SIP URI(统一资源标识符)，这些都是==SIP实体</strong></p>
<ul>
<li>SIP中的网络元素</li>
</ul>
<ol>
<li>用户代理</li>
<li>代理服务器</li>
<li>注册服务器</li>
<li>重定向服务器</li>
<li>位置服务器</li>
</ol>
<ul>
<li>SIP层次结构<br>SIP协议为分层协议，这可以相对独立的处理每层的行为，保证了层次之间的松耦合。</li>
</ul>
<p>SIP的最下层是它的语法和编码。它的编码是用扩充Backus-Naur 范式语法（BNF）指定。</p>
<p>第二层是传输层。它定义了一个客户端发送请求和接收响应以及一个服务器如何接收请求和发送响应。所有的SIP网络元素都包含传输层。</p>
<p>第三层是事务层。事务是由客户端（使用传输层）发送到服务器的请求，还包含所有响应服务器给客户端发送的响应。用户代理客户端（UAC）包含一系列事物的处理。无状态代理不包含事务层。</p>
<p>事务层以上的层称为事务用户。每个SIP实体，除了无状态代理，都是一个事务用户。</p>
<p><strong>SIP事务：包含请求和响应。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/12/java线程池简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/12/java线程池简介/" itemprop="url">java并发编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-12T00:34:14+08:00">
                2018-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ExecutorService简介"><a href="#ExecutorService简介" class="headerlink" title="ExecutorService简介"></a>ExecutorService简介</h2><p>ExecutorService 的生命周期包括三种状态：运行、关闭、终止。创建后便进入运行状态，当调用了 shutdown（）方法时，便进入关闭状态，此时意味着 ExecutorService 不再接受新的任务，但它还在执行已经提交了的任务，当素有已经提交了的任务执行完后，便到达终止状态。如果不调用 shutdown（）方法，ExecutorService 会一直处在运行状态，不断接收新的任务，执行新的任务，服务器端一般不需要关闭它，保持一直运行即可。</p>
<h2 id="Executors类提供的4种工厂方法"><a href="#Executors类提供的4种工厂方法" class="headerlink" title="Executors类提供的4种工厂方法"></a>Executors类提供的4种工厂方法</h2><ol>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>创建固定数目线程的线程池。</p>
<p>2.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线 程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</p>
<ol start="3">
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>创建一个单线程化的Executor。</p>
<ol start="4">
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</p>
<h2 id="四种创建ExecutorService方式的区别"><a href="#四种创建ExecutorService方式的区别" class="headerlink" title="四种创建ExecutorService方式的区别"></a>四种创建ExecutorService方式的区别</h2><ol>
<li><strong>newCachedThreadPool()</strong></li>
</ol>
<p>缓存型池子，先查看池中有没有以前建立的线程，如果有，就 reuse<br>如果没有，就建一个新的线程加入池中</p>
<p>缓存型池子通常用于执行一些生存期很短的异步型任务 因此在一些面向连接的 daemon 型 SERVER 中用得不多。但对于生存期短的异步任务，它是 Executor 的首选。</p>
<p>能 reuse 的线程，必须是 timeout IDLE 内的池中线程，缺省 timeout 是 60s,超过这个 IDLE 时长，线程实例将被终止及移出池。</p>
<p>注意，放入 CachedThreadPool 的线程不必担心其结束，超过 TIMEOUT 不活动，其会自动被终止。</p>
<ol start="2">
<li><strong>newFixedThreadPool(int)</strong></li>
</ol>
<p>newFixedThreadPool 与 cacheThreadPool 差不多，也是能 reuse 就用，但不能随时建新的线程。</p>
<p>其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。</p>
<p>和 cacheThreadPool 不同，FixedThreadPool 没有 IDLE 机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的 TCP 或 UDP IDLE 机制之类的），所以 FixedThreadPool 多数针对一些很稳定很固定的正规并发线程，多用于服务器。</p>
<p>从方法的源代码看，cache池和fixed 池调用的是同一个底层 池，只不过参数不同:<br>fixed 池线程数固定，并且是0秒IDLE（无IDLE）。<br>cache 池线程数支持 0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60 秒 IDLE 。</p>
<ol start="3">
<li><strong>newScheduledThreadPool(int)</strong></li>
</ol>
<p>调度型线程池</p>
<p>这个池子里的线程可以按 schedule 依次 delay 执行，或周期执行</p>
<ol start="4">
<li><strong>SingleThreadExecutor()</strong></li>
</ol>
<p>单例线程，任意时间池中只能有一个线程</p>
<p>用的是和 cache 池和 fixed 池相同的底层池，但线程数目是 1-1,0 秒 IDLE（无 IDLE）</p>
<p><strong>一般来说，CachedTheadPool 在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的 Executor 的首选，只有当这种方式会引发问题时（比如需要大量长时间面向连接的线程时），才需要考虑用 FixedThreadPool。（该段话摘自《Thinking in Java》第四版）</strong></p>
<h2 id="Executor执行Runnable任务"><a href="#Executor执行Runnable任务" class="headerlink" title="Executor执行Runnable任务"></a>Executor执行Runnable任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCachedThreadPool</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();   </span><br><span class="line"><span class="comment">//      ExecutorService executorService = Executors.newFixedThreadPool(5);  </span></span><br><span class="line"><span class="comment">//      ExecutorService executorService = Executors.newSingleThreadExecutor();  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;   </span><br><span class="line">            executorService.execute(<span class="keyword">new</span> TestRunnable());   </span><br><span class="line">            System.out.println(<span class="string">"************* a"</span> + i + <span class="string">" *************"</span>);   </span><br><span class="line">        &#125;   </span><br><span class="line">        executorService.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"线程被调用了。"</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ExecutorZ执行Callable任务"><a href="#ExecutorZ执行Callable任务" class="headerlink" title="ExecutorZ执行Callable任务"></a>ExecutorZ执行Callable任务</h2><p>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常而 Callable 又返回结果，而且当获取返回结果时可能会抛出异常。Callable 中的 call()方法类似 Runnable 的 run()方法，区别同样是有返回值，后者没有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;   </span><br><span class="line"><span class="keyword">import</span> java.util.List;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();   </span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();   </span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建10个任务并执行   </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;   </span><br><span class="line">            <span class="comment">//使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中   </span></span><br><span class="line">            Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> TaskWithResult(i));   </span><br><span class="line">            <span class="comment">//将任务执行结果存储到List中   </span></span><br><span class="line">            resultList.add(future);   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历任务的结果   </span></span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fs : resultList)&#123;   </span><br><span class="line">                <span class="keyword">try</span>&#123;   </span><br><span class="line">                    <span class="keyword">while</span>(!fs.isDone);<span class="comment">//Future返回如果没有完成，则一直循环等待，直到Future返回完成  </span></span><br><span class="line">                    System.out.println(fs.get());     <span class="comment">//打印各个线程（任务）执行的结果   </span></span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;   </span><br><span class="line">                    e.printStackTrace();   </span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;   </span><br><span class="line">                    <span class="comment">//启动一次顺序关闭，执行以前提交的任务，但不接受新任务  </span></span><br><span class="line">                    executorService.shutdown();   </span><br><span class="line">                &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.id = id;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 任务的具体过程，一旦任务传给ExecutorService的submit方法， </span></span><br><span class="line"><span class="comment">     * 则该方法自动在一个线程上执行 </span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"call()方法被自动调用！！！    "</span> + Thread.currentThread().getName());   </span><br><span class="line">        <span class="comment">//该返回结果将被Future的get方法得到  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"call()方法被自动调用，任务返回的结果是："</span> + id + <span class="string">"    "</span> + Thread.currentThread().getName();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>一般使用ThreadPoolExecutor类来创建自定义的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;   </span><br><span class="line">        <span class="comment">//创建等待队列   </span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>);   </span><br><span class="line">        <span class="comment">//创建线程池，池中保存的线程数为3，允许的最大线程数为5  </span></span><br><span class="line">        ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>,<span class="number">5</span>,<span class="number">50</span>,TimeUnit.MILLISECONDS,bqueue);   </span><br><span class="line">        <span class="comment">//创建七个任务   </span></span><br><span class="line">        Runnable t1 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t2 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t3 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t4 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t5 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t6 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        Runnable t7 = <span class="keyword">new</span> MyThread();   </span><br><span class="line">        <span class="comment">//每个任务会在一个线程上执行  </span></span><br><span class="line">        pool.execute(t1);   </span><br><span class="line">        pool.execute(t2);   </span><br><span class="line">        pool.execute(t3);   </span><br><span class="line">        pool.execute(t4);   </span><br><span class="line">        pool.execute(t5);   </span><br><span class="line">        pool.execute(t6);   </span><br><span class="line">        pool.execute(t7);   </span><br><span class="line">        <span class="comment">//关闭线程池   </span></span><br><span class="line">        pool.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"正在执行。。。"</span>);   </span><br><span class="line">        <span class="keyword">try</span>&#123;   </span><br><span class="line">            Thread.sleep(<span class="number">100</span>);   </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </span><br><span class="line">            e.printStackTrace();   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简要说明下用到的 ThreadPoolExecuror 类的构造方法中各个参数的含义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span> <span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span>         keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>corePoolSize：线程池中所保存的核心线程数，包括空闲线程。</p>
</li>
<li><p>maximumPoolSize：池中允许的最大线程数。</p>
</li>
<li><p>keepAliveTime：线程池中的空闲线程所能持续的最长时间。</p>
</li>
<li><p>unit：持续时间的单位。</p>
</li>
<li><p>workQueue：任务执行前保存任务的队列，仅保存由 execute 方法提交的 Runnable 任务。</p>
</li>
</ul>
<h2 id="使用ThreadPoolExecutor类自定义线程池任务添加时处理的顺序"><a href="#使用ThreadPoolExecutor类自定义线程池任务添加时处理的顺序" class="headerlink" title="使用ThreadPoolExecutor类自定义线程池任务添加时处理的顺序"></a>使用ThreadPoolExecutor类自定义线程池任务添加时处理的顺序</h2><ol>
<li>如果线程池中的线程数量少于 corePoolSize，即使线程池中有空闲线程，也会创建一个新的线程来执行新添加的任务</li>
<li>如果线程池中的线程数量大于等于 corePoolSize，但缓冲队列 workQueue 未满，则将新添加的任务放到 workQueue 中，按照 FIFO 的原则依次等待执行（线程池中有线程空闲出来后依次将缓冲队列中的任务交付给空闲的线程执行）</li>
<li>如果线程池中的线程数量大于等于 corePoolSize，且缓冲队列 workQueue 已满，但线程池中的线程数量小于 maximumPoolSize，则会创建新的线程来处理被添加的任务</li>
<li>如果线程池中的线程数量等于了 maximumPoolSize，有 4 种才处理方式（该构造方法调用了含有 5 个参数的构造方法，并将最后一个构造方法为 RejectedExecutionHandler 类型，它在处理线程溢出时有 4 种方式，这里不再细说，要了解的，自己可以阅读下源码）</li>
</ol>
<p><strong>总结起来，也即是说，当有新的任务要处理时，先看线程池中的线程数量是否大于 corePoolSize，再看缓冲队列 workQueue 是否满，最后看线程池中的线程数量是否大于 maximumPoolSize。</strong></p>
<p>当线程池中的线程数量<strong>大于</strong> corePoolSize 时，如果里面有线程的空闲时间超过了 keepAliveTime，就将其移除线程池，这样，可以动态地调整线程池中线程的数量</p>
<h2 id="this逃逸的解决办法"><a href="#this逃逸的解决办法" class="headerlink" title="this逃逸的解决办法"></a>this逃逸的解决办法</h2><p>可以在构造函数中创建线程，但别启动它。在构造函数外面再启动。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/10/ListView和RecyclerView的卡顿优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/10/ListView和RecyclerView的卡顿优化/" itemprop="url">ListView和RecyclerView的卡顿优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-10T00:34:14+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>由于ListView和RecyclerView的缓存机制，<strong>滚动时会额外通过getView或者onCreateViewHolder  里面继续inflate布局造成的。</strong></p>
<p><strong>因为它们的缓存机制导致，初始化只加载可视范围内的item</strong></p>
<h2 id="ListView优化方式"><a href="#ListView优化方式" class="headerlink" title="ListView优化方式"></a>ListView优化方式</h2><p><strong>利用反射机制，调用addViewBelow方法，让ListView 预先加载item , 也就是让它多加载几个item , 使之滚动的时候， 不去创建layout ， 而是使用缓存好的item 。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Method method = ShareReflectUtil.findMethod(<span class="keyword">this</span>,<span class="string">"addViewBelow"</span>,View.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">intposition = getLastVisiblePosition();</span><br><span class="line"></span><br><span class="line">View view = getChildAt(position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(inti =<span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line"></span><br><span class="line">    method.invoke(<span class="keyword">this</span>,view,i + position);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RecyclerView优化方式"><a href="#RecyclerView优化方式" class="headerlink" title="RecyclerView优化方式"></a>RecyclerView优化方式</h2><p><strong>RecyclerView也是利用RecycledViewPool内部类在缓存池中预先加载好几个ViewHolder。</strong></p>
<p><strong>一定要在setAdapter之后调用， 否者无效， 因为setAdapter时会清除你的pool缓存。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView.RecycledViewPool pool = recyclerView.getRecycledViewPool();</span><br><span class="line"></span><br><span class="line">pool.setMaxRecycledViews(viewType,count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(intindex =<span class="number">0</span>;index &lt; count;index++) &#123;</span><br><span class="line"></span><br><span class="line">    pool.putRecycledView(recyclerView.getAdapter().createViewHolder(recyclerView,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/09/JNI 局部引用 全局引用 弱全局引用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/JNI 局部引用 全局引用 弱全局引用/" itemprop="url">JNI 局部引用 全局引用 弱全局引用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-09T00:34:14+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="局部引用（最普通的引用）"><a href="#局部引用（最普通的引用）" class="headerlink" title="局部引用（最普通的引用）"></a>局部引用（最普通的引用）</h2><p>通过<strong>NewLocalRef和各种JNI接口创建（FindClass、NewObject、GetObjectClass和NewCharArray等）==。会阻止GC回收所引用的对象，不在本地函数中跨函数使用，不能跨线程使用。==函数返回后局部引用所会被JVM自动释放，或调用DeleteLocalRef释放,进而导致其指向的java堆中的对象也被释放。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2790119-f40d4f23ebdf8e21.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/406" alt="img"><br><strong>局部引用，和局部变量不同，其位于局部引用表中</strong>，Android JNI局部引用表的上限是512个，因此应该及时删除局部引用。</p>
<h2 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h2><p>调用NewGlobalRef<strong>基于局部引用创建</strong>，会阻GC回收所引用的对象。可以跨方法、跨线程使用。JVM不会自动释放，必须调用DeleteGlobalRef手动释放(*env)-&gt;DeleteGlobalRef(env,g_cls_string)</p>
<h2 id="弱全局引用"><a href="#弱全局引用" class="headerlink" title="弱全局引用"></a>弱全局引用</h2><p>调用NewWeakGlobalRef<strong>基于局部引用或全局引用创建==，不会阻止GC回收所引用的对象，可以跨方法、跨线程使用。引用不会被JVM自动释放，在JVM认为应该回收它的时候（比如==内存紧张</strong>的时候）进行回收而被释放。或调用DeleteWeakGlobalRef手动释放。</p>
<p><strong>当我们的本地代码不再需要一个弱全局引用时，也应该调用 DeleteWeakGlobalRef 来释放它，如果不手动调用这个函数来释放所指向的对象，JVM 仍会回收弱引用所指向的对象，但弱引用本身在引用表中所占的内存永远也不会被回收。</strong></p>
<h2 id="Native-Method删除局部引用的过程"><a href="#Native-Method删除局部引用的过程" class="headerlink" title="Native Method删除局部引用的过程"></a>Native Method删除局部引用的过程</h2><p>native method 调用 DeleteLocalRef() 释放某个 JNI Local Reference 时，首先通过指针 p 定位相应的 Local Reference 在 Local Ref 表中的位置，然后从 Local Ref 表中删除该 Local Reference，也就取消了对相应 Java 对象的引用（Ref count 减 1）</p>
<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><p>局部引用属于JNI中的概念，由于C/C++中没有对象的概念，所以我们<strong>一般说局部引用表存储在native heap中==。类似于==java heap中存储者对象以及对应的弱引用、软引用对象等等</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/java自身实现观察者模式的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/java自身实现观察者模式的方法/" itemprop="url">java自身实现观察者模式的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T00:34:14+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Observer接口和Observable类"><a href="#Observer接口和Observable类" class="headerlink" title="Observer接口和Observable类"></a>Observer接口和Observable类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Observer&#125; is the interface to be implemented by objects that</span></span><br><span class="line"><span class="comment"> * receive notification of updates on an &#123;<span class="doctag">@code</span> Observable&#125; object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Observable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is called if the specified &#123;<span class="doctag">@code</span> Observable&#125; object's</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> notifyObservers&#125; method is called (because the &#123;<span class="doctag">@code</span> Observable&#125;</span></span><br><span class="line"><span class="comment">     * object has been updated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observable</span></span><br><span class="line"><span class="comment">     *            the &#123;<span class="doctag">@link</span> Observable&#125; object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     *            the data passed to &#123;<span class="doctag">@link</span> Observable#notifyObservers(Object)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object data)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Antique</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mPrice;<span class="comment">// 价钱</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Antique</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mPrice = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setChanged();</span><br><span class="line">        <span class="keyword">super</span>.notifyObservers(price);<span class="comment">// 价格被改变</span></span><br><span class="line">        <span class="keyword">this</span>.mPrice = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"古董价格为："</span> + <span class="keyword">this</span>.mPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object data)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">""</span>,<span class="string">"People update() -&gt; update name:"</span>+ <span class="keyword">this</span>.name + <span class="string">",price:"</span>+ ((Float)data).floatValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/06/Java动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/06/Java动态代理/" itemprop="url">Java动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-06T00:34:14+08:00">
                2018-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>java动态代理可以动态地创建代理并且动态地处理对所代理方法的调用。</p>
<p>在动态代理上做的所有调用都会被重定向到单一的调用处理器（InvocationHandler）上</p>
<h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Object proxied)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="comment">//对传入的参数做一些逻辑处理</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RealObject realObject = <span class="keyword">new</span> RealObject();</span><br><span class="line"></span><br><span class="line">Interface proxy = (Interface)Proxy.newProxyInstance(Interface.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;Interface.class&#125;,<span class="keyword">new</span> ProxyHandler(realObject));</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/05/OKHTTP缓存机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/OKHTTP缓存机制/" itemprop="url">OKHTTP缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T00:34:14+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTP-Response中Cache-Control字段的含义"><a href="#HTTP-Response中Cache-Control字段的含义" class="headerlink" title="HTTP Response中Cache-Control字段的含义"></a>HTTP Response中Cache-Control字段的含义</h2><ul>
<li><strong>max-age</strong>：这个参数告诉浏览器将页面缓存多长时间，超过这个时间后才再次向服务器发起请求检查页面是否有更新。对于静态的页面，比如图片、CSS、Javascript，一般都不大变更，因此通常我们将存储这些内容的时间设置为较长的时间，这样浏览器会不会向浏览器反复发起请求，也不会去检查是否更新了。</li>
<li>s-maxage：这个参数告诉缓存服务器(proxy，如Squid)的缓存页面的时间。如果不单独指定，缓存服务器将使用max-age。对于动态内容(比如文档的查看页面)，我们可告诉浏览器很快就过时了(max-age=0)，并告诉缓存服务器(Squid)保留内容一段时间(比如，s-maxage=7200)。一旦我们更新文档，我们将告诉Squid清除老的缓存版本。</li>
<li>must-revalidate：这告诉浏览器，一旦缓存的内容过期，一定要向服务器询问是否有新版本。</li>
<li>proxy-revalidate：proxy上的缓存一旦过期，一定要向服务器询问是否有新版本。</li>
<li><strong>no-cache</strong>：不做缓存。</li>
<li><strong>no-store</strong>：数据不在硬盘中临时保存，这对需要保密的内容比较重要。</li>
<li>public：告诉缓存服务器, 即便是对于不该缓存的内容也缓存起来，比如当用户已经认证的时候。所有的静态内容(图片、Javascript、CSS等)应该是public的。</li>
<li>private：告诉proxy不要缓存，但是浏览器可使用private cache进行缓存。一般登录后的个性化页面是private的。</li>
<li>no-transform: 告诉proxy不进行转换，比如告诉手机浏览器不要下载某些图片。</li>
<li><strong>max-stale</strong>指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>
</ul>
<h2 id="OKHTTP缓存设置"><a href="#OKHTTP缓存设置" class="headerlink" title="OKHTTP缓存设置"></a>OKHTTP缓存设置</h2><ol>
<li><strong>服务器支持缓存</strong></li>
</ol>
<p>cache-control字段返回max-age,只需要手动给okhttp设置缓存就可以让okhttp自动帮你缓存,这个缓存时间也可以自定义修改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">httpClientBuilder</span><br><span class="line">    .cache(cache)</span><br><span class="line">    .connectTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br><span class="line">    .readTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>连接时间：发送请求开始到与目标主机建立连接所需的时间。</p>
</blockquote>
<blockquote>
<p>读取时间：已经连接到了目标服务器后，将数据完全读取所需的时间。</p>
</blockquote>
<ol start="2">
<li><strong>服务器不支持缓存</strong></li>
</ol>
<p>cache-control字段未指定或者指定为no-store等等，此时可以用interceptor拦截response并手动添加header</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line">        Response response1 = response.newBuilder()</span><br><span class="line">            .removeHeader(<span class="string">"Pragma"</span>)</span><br><span class="line">            .removeHeader(<span class="string">"Cache-Control"</span>)</span><br><span class="line">            <span class="comment">//cache for 30 days</span></span><br><span class="line">            .header(<span class="string">"Cache-Control"</span>, <span class="string">"max-age="</span> + <span class="number">3600</span> * <span class="number">24</span> * <span class="number">30</span>)</span><br><span class="line">            .build();</span><br><span class="line">        <span class="keyword">return</span> response1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">httpClientBuilder</span><br><span class="line">    .addNetworkInterceptor(<span class="keyword">new</span> CacheInterceptor())</span><br><span class="line">    .cache(cache)</span><br><span class="line">    .connectTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br><span class="line">    .readTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/Volley源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/Volley源码解析/" itemprop="url">Volley源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T00:34:14+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Volley工作流程图"><a href="#Volley工作流程图" class="headerlink" title="Volley工作流程图"></a>Volley工作流程图</h2><p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png" alt="img"></p>
<h2 id="从Volley-newRequestQueue-this-到Request-deliveryResponse-中Listener-onResponse-的回调全过程"><a href="#从Volley-newRequestQueue-this-到Request-deliveryResponse-中Listener-onResponse-的回调全过程" class="headerlink" title="从Volley.newRequestQueue(this)到Request.deliveryResponse()中Listener.onResponse()的回调全过程"></a>从Volley.newRequestQueue(this)到Request.deliveryResponse()中Listener.onResponse()的回调全过程</h2><ol>
<li><p>Volley.newRequestQueue(this)</p>
<ol>
<li>首先调用两个参数的构造方法，context和BaseHttpStack（null）</li>
<li>然后构造Network接口的具体实现BasicNetWork，分api版本判断，如果是大于等于9，使用httpurlconnection（对应HurlStack），如果小于9，使用httpclient（对应HttpClientStack）</li>
<li>最后调用真正的构造方法，也是两个参数，context和network，在其中new RequestQueue实例，传入cache（系统默认是DiskBasedCache）和network</li>
<li>requestQueue构造方法里面最后调用到四个参数的构造方法，分别对应cache、network、网络请求的线程数量、ResponseDelivery。其中ResponseDelivery的具体实现类是ExecutorDelivery,其构造方法中传入了Looper.getMainLooper()获取的主线程的Looper，因此也<strong>决定了Volley的响应默认是回调在主线程中==（==这里充分体现出Volley设计的特点：针对接口编程，不针对具体实现编程,策略模式</strong>）</li>
<li>然后最后在newRequestQueue最后调用queue.start()</li>
</ol>
</li>
<li><p>RequestQueue.start()</p>
<ol>
<li>主要作用是启动CacheDispatcher和NetworkDispatcher(默认是1个cacheDispatcher和4个NetworkDispatcher，最多5个后台线程)</li>
<li>其中RequestQueue中保存的cacheQueue和networkQueue都是PriorityBlockingQueue,线程安全的优先级阻塞队列。（<strong>通过put/take进行操作</strong>）</li>
</ol>
</li>
<li><p>CacheDispatcher <strong>extends Thread</strong></p>
<ol>
<li>cacheDispatcher构造方法传入四个参数，mCacheQueue,mNetworkQueue,mCache,mDelivery,<strong>最后在构造函数中还会初始化一个WaitingRequestManager的实例</strong>，其主要作用是保存那些重复的请求，其中主要的数据结构是一个Map&lt;String,List<request>&gt;,对应cacheKey（默认是url）和重复的请求列表</request></li>
<li>run()方法中有个死循环，里面是processRequest()处理请求</li>
<li>请求包括两种情况，cache hit和cache miss，hit包括soft-expired和completely unexpired,miss包括不存在对应cache和expired</li>
<li>miss情况下直接将request放进mNetworkQueue中</li>
<li>hit情况下需要分情况考虑，如果完全未过期，直接调用mDelivery.postResponse(response,request)，解析response并且传给mDeliverz中定义的(Executor)mResponsePoster进行处理;如果快过期，需要先传递cache中的response，然后再重新做一次网络请求。<strong>这时还需要分情况判断，如果这个请求是重复的，那么不需要做网络请求，如果不是则需要</strong>。分别调用mDelivery.postResponse(response,request)和mDelivery.postResponse(response,request,runnable)方法，runnable会在传递完成之后执行。</li>
</ol>
</li>
</ol>
<ol start="4">
<li><p>NetworkDispatcher <strong>extends Thread</strong></p>
<ol>
<li>networkDispatcher构造方法传入四个参数，mNetworkQueue,mNetwork,mCache,mDelivery</li>
<li>run()方法中有个死循环，里面是processRequest()处理请求</li>
<li>其中<strong>由mNetwork.performRequest(request)完成网络请求，传入的network接口实现是BasicNetwork，其中传入的初始化参数为BaseHttpStack的实现类HurlStack，所以最后调用hurlstack中的executeRequest()方法，这时候使用httpurlconnection来进行网络请求，然后返回原始网络数据（raw response）</strong></li>
<li>然后调用reqeust的parseNetworkResponse方法来将原始的响应数据解析成正确格式的数据。</li>
<li>判断是否应该写入缓存，如果需要，则写入mCache中</li>
<li>最后调用mDelivery.postResponse(reqeust,reponse)来传递数据。</li>
</ol>
</li>
<li><p>ResponseDelivery.postResponse()</p>
<ol>
<li>具体实现类是ExecutorDelivery，然后最后都会调用postResponse(request,response,runnable)方法</li>
<li>该方法解析response并且传给mDelivery中定义的(Executor)mResponsePoster进行处理，由于之前传入的是主线程的Looper，所以在execute（）方法调用的handler.post()方法对应会在主线程执行</li>
<li>然后传入的execute()方法的runnable对象是私有内部类实例,ResponseDeliveryRunnable,构造函数中传入request,response,runnable,主要逻辑是判断response是否成功，如果成功回调request.deliverResponse()，不成功，回调request.deliverError(),，然后最后执行runnable。<strong>其中deliverResponse()通常自定义request时需要重写，一般在其中回调listenr.onResponse()方法，从而显示响应结果。</strong></li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/02/JNI创建线程的方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/02/JNI创建线程的方式/" itemprop="url">JNI创建线程的方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-02T00:34:14+08:00">
                2018-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="调用C语言函数"><a href="#调用C语言函数" class="headerlink" title="调用C语言函数"></a>调用C语言函数</h2><ol>
<li>pthread_create(&amp;mThread, NULL, AlertThreadStub, NULL)</li>
<li>attachCurrentThread()、detachCurrentThread()<br><br> 很多时候，你的native代码建立自己的线程（比如建立线程监听），并在合适的时候回调 Java 代码，我们没有办法像上面那样直接获得 JNIEnv，<strong>获取它的实例需要把你的线程 Attach到JavaVM上去</strong>，调用的方法是 JavaVM::AttachCurrentThread</li>
</ol>
<p>具体实例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     JNIEnv *env;</span><br><span class="line">     jclass cls;</span><br><span class="line">     jmethodID mid;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//Attach主线程</span></span><br><span class="line">     <span class="keyword">if</span>((*g_jvm)-&gt;AttachCurrentThread(g_jvm, &amp;env, <span class="literal">NULL</span>) != JNI_OK)</span><br><span class="line">     &#123;</span><br><span class="line">         LOGE(<span class="string">"%s: AttachCurrentThread() failed"</span>, __FUNCTION__);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//找到对应的类</span></span><br><span class="line">     cls = (*env)-&gt;GetObjectClass(env,g_obj);</span><br><span class="line">     <span class="keyword">if</span>(cls == <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         LOGE(<span class="string">"FindClass() Error....."</span>);</span><br><span class="line">         <span class="keyword">goto</span> error; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//再获得类中的方法</span></span><br><span class="line">     mid = (*env)-&gt;GetStaticMethodID(env, cls, <span class="string">"fromJNI"</span>, <span class="string">"(I)V"</span>);</span><br><span class="line">     <span class="keyword">if</span> (mid == <span class="literal">NULL</span>) </span><br><span class="line">     &#123;</span><br><span class="line">         LOGE(<span class="string">"GetMethodID() Error....."</span>);</span><br><span class="line">         <span class="keyword">goto</span> error;  </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//最后调用java中的静态方法</span></span><br><span class="line">         (*env)-&gt;CallStaticVoidMethod(env, cls, mid ,(<span class="keyword">int</span>)arg);</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line"> error:    </span><br><span class="line">     <span class="comment">//Detach主线程</span></span><br><span class="line">     <span class="keyword">if</span>((*g_jvm)-&gt;DetachCurrentThread(g_jvm) != JNI_OK)</span><br><span class="line">     &#123;</span><br><span class="line">         LOGE(<span class="string">"%s: DetachCurrentThread() failed"</span>, __FUNCTION__);     &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">     pthread_exit(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由java调用以创建子线程</span></span><br><span class="line"> <span class="function">JNIEXPORT <span class="keyword">void</span> <span class="title">Java_com_nan_thread_MyThreadActivity_mainThread</span><span class="params">( JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">pthread_t</span> pt[NUMTHREADS];</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMTHREADS; i++)</span><br><span class="line">         <span class="comment">//创建子线程</span></span><br><span class="line">         pthread_create(&amp;pt[i], <span class="literal">NULL</span>, &amp;thread_fun, (<span class="keyword">void</span> *)i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">114</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/valleypioneer" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:13261702056@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
